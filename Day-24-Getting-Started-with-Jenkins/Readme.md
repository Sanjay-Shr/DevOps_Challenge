# Day 24 | DevOps Challenge — Getting Started with Jenkins

Today, I began my journey with one of the most essential DevOps tools — **Jenkins**.  
I focused on understanding how Jenkins automates the entire process of building, testing, and deploying applications continuously, making it a cornerstone of modern DevOps workflows.

---

## What I Did

1. Learned the core concept of Jenkins and its role in automating CI/CD pipelines.  
2. Understood the difference between **Continuous Integration** and **Continuous Delivery/Deployment**.  
3. Explored Jenkins usage across **AWS**, **Azure**, and **GCP** environments.  
4. Set up Jenkins on my local machine and created my **first admin user**.  
5. Discovered that each automation task in Jenkins is defined as a **Job** — such as cloning repositories, automating builds, or running test scripts.  
6. Created my first **Freestyle Project Job**, configured it to execute shell commands, and verified that it successfully created folders and displayed outputs.  
7. Observed the complete flow — from configuration to build execution — to understand how Jenkins manages automation end-to-end.

---

## Key Takeaways

1. Jenkins forms the **foundation of DevOps automation** and CI/CD pipelines.  
2. Understanding **jobs and builds** helps design efficient automation workflows.  
3. A simple, successful job marks the first real step toward mastering Jenkins pipelines.  
4. Jenkins can integrate seamlessly with **cloud platforms** like AWS, Azure, and GCP.  
5. Continuous Integration and Deployment are what make software delivery **faster, more reliable, and error-free**.

---

## Reflection

Today’s session gave me a practical start with Jenkins — from setup to job execution.  
This exercise reinforced how automation tools like Jenkins simplify complex workflows and ensure continuous delivery of software.

#DevOps #Jenkins #CICD #Automation #LearningByDoing #Linux #BuildAutomation

